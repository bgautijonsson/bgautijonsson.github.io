<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="dcterms.date" content="2024-12-19">
<meta name="description" content="This post introduces Archimedean copulas, a flexible alternative to elliptical copulas for modeling dependence. We explore their construction using generator functions, connections to Laplace transforms, and the theoretical foundations for their implementation in Stan. Future posts will delve into specific Archimedean families like Clayton, Gumbel, and Frank.">

<title>Building Blocks: Understanding Archimedean Copulas – bggj</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ac866aed7c6e28a9d250fd53e0d1b6ea.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-25756194e7ad27d67dfde92e39ce2c95.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EGQ9KVCY2C"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-EGQ9KVCY2C', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Building Blocks: Understanding Archimedean Copulas – bggj">
<meta property="og:description" content="This post introduces Archimedean copulas, a flexible alternative to elliptical copulas for modeling dependence. We explore their construction using generator functions, connections to Laplace transforms, and the theoretical foundations for their implementation in Stan. Future posts will delve into specific Archimedean families like Clayton, Gumbel, and Frank.">
<meta property="og:image" content="https://www.bggj.is/posts/archimedean-copulas/images/archimedean_copulas.jpg">
<meta property="og:site_name" content="bggj">
<meta name="twitter:title" content="Building Blocks: Understanding Archimedean Copulas – bggj">
<meta name="twitter:description" content="This post introduces Archimedean copulas, a flexible alternative to elliptical copulas for modeling dependence. We explore their construction using generator functions, connections to Laplace transforms, and the theoretical foundations for their implementation in Stan. Future posts will delve into specific Archimedean families like Clayton, Gumbel, and Frank.">
<meta name="twitter:image" content="https://www.bggj.is/posts/archimedean-copulas/images/archimedean_copulas.jpg">
<meta name="twitter:creator" content="@bggjonsson">
<meta name="twitter:site" content="@bggjonsson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bggj</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/bggjonsson"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bgautijonsson/bgautijonsson.github.io"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Building Blocks: Understanding Archimedean Copulas</h1>
            <p class="subtitle lead">Copulas in Stan: Episode IV</p>
                  <div>
        <div class="description">
          This post introduces Archimedean copulas, a flexible alternative to elliptical copulas for modeling dependence. We explore their construction using generator functions, connections to Laplace transforms, and the theoretical foundations for their implementation in Stan. Future posts will delve into specific Archimedean families like Clayton, Gumbel, and Frank.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">stan</div>
                <div class="quarto-category">copulas</div>
                <div class="quarto-category">copulas in stan</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="bggj.is">Brynjólfur Gauti Guðrúnar Jónsson</a> </p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              <a href="https://www.hi.is/tolfraedi_0">
              Tölfræði, Raunvísindadeild Háskóla Íslands
              </a>
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 19, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#recap-what-we-know-about-copulas" id="toc-recap-what-we-know-about-copulas" class="nav-link active" data-scroll-target="#recap-what-we-know-about-copulas">Recap: What We Know About Copulas</a></li>
  <li><a href="#the-core-idea-generator-functions" id="toc-the-core-idea-generator-functions" class="nav-link" data-scroll-target="#the-core-idea-generator-functions">The Core Idea: Generator Functions</a>
  <ul class="collapse">
  <li><a href="#key-properties-of-the-generator" id="toc-key-properties-of-the-generator" class="nav-link" data-scroll-target="#key-properties-of-the-generator">Key Properties of the Generator</a></li>
  </ul></li>
  <li><a href="#from-generators-to-copulas-a-construction" id="toc-from-generators-to-copulas-a-construction" class="nav-link" data-scroll-target="#from-generators-to-copulas-a-construction">From Generators to Copulas: A Construction</a></li>
  <li><a href="#connection-to-laplace-transforms" id="toc-connection-to-laplace-transforms" class="nav-link" data-scroll-target="#connection-to-laplace-transforms">Connection to Laplace Transforms</a></li>
  <li><a href="#theoretical-foundations-for-implementation-in-stan" id="toc-theoretical-foundations-for-implementation-in-stan" class="nav-link" data-scroll-target="#theoretical-foundations-for-implementation-in-stan">Theoretical Foundations for Implementation in Stan</a></li>
  <li><a href="#a-look-ahead" id="toc-a-look-ahead" class="nav-link" data-scroll-target="#a-look-ahead">A Look Ahead</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In the previous posts of this series, we laid the groundwork for understanding copulas and explored the Gaussian and Student’s t families. The Gaussian and t-copulas belong to a class often referred to as <em>elliptical copulas</em>, distinguished by their construction from elliptically distributed random vectors. While these copulas are critical tools, especially given their ubiquity in finance and statistics, they’re not the only game in town. Today, we turn our attention to a different family: the Archimedean copulas.</p>
<p><strong>Previous posts in this series:</strong></p>
<ol type="1">
<li><a href="../stan-copulas-1/index.html">Introduction to Copulas in Stan</a></li>
<li><a href="../gaussian-copula/index.html">A Gentle Introduction: The Gaussian Copula</a></li>
<li><a href="../t-copula/index.html">It was the best of tails, it was the worst of tails: The t-Copula</a></li>
</ol>
<hr>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Elliptical Distributions and Copulas
</div>
</div>
<div class="callout-body-container callout-body">
<p>Elliptical distributions generalize the multivariate normal distribution by allowing for elliptical, rather than strictly spherical, contours of constant density. A <span class="math inline">\(d\)</span>-dimensional random vector <span class="math inline">\(\mathbf{X}\)</span> has an elliptical distribution if it can be represented as:</p>
<p><span class="math display">\[
\mathbf{X} \stackrel{d}{=} \boldsymbol{\mu} + A \mathbf{Y},
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\boldsymbol{\mu}\)</span> is a location vector,</li>
<li><span class="math inline">\(A\)</span> is a scale matrix such that <span class="math inline">\(\Sigma = A A^\top\)</span>,</li>
<li><span class="math inline">\(\mathbf{Y} \stackrel{d}{=} R \mathbf{S}\)</span>, where <span class="math inline">\(R \geq 0\)</span> is a radial random variable, and <span class="math inline">\(\mathbf{S}\)</span> is uniformly distributed on the unit sphere.</li>
</ul>
<p>Elliptical copulas are derived from elliptical distributions via Sklar’s Theorem. For example, the Gaussian copula corresponds to a multivariate normal distribution, and the <span class="math inline">\(t\)</span>-copula corresponds to a multivariate <span class="math inline">\(t\)</span>-distribution. These copulas capture the dependence structure of elliptical distributions but are limited in describing asymmetric or extreme dependencies.</p>
</div>
</div>
<p>Archimedean copulas offer an elegant, flexible alternative to elliptical copulas. Their construction is defined through a single real-valued function known as a <em>generator</em>, and this approach provides a wide range of tail dependence characteristics—particularly useful when we need to capture more asymmetric dependence structures. In subsequent posts, we’ll explore specific Archimedean copulas (like Clayton, Gumbel, and Frank), each with its unique flavor of dependence.</p>
<section id="recap-what-we-know-about-copulas" class="level2">
<h2 class="anchored" data-anchor-id="recap-what-we-know-about-copulas">Recap: What We Know About Copulas</h2>
<p>To set the stage, recall that a copula is a multivariate distribution defined on the unit hypercube, describing the dependence structure among random variables independently of their marginal distributions. By separating the joint distribution into a copula and a set of marginal distributions, we can mix and match marginals with various dependency templates. So far, we’ve seen:</p>
<ul>
<li><strong>Gaussian Copula:</strong> An elliptical copula derived from the Gaussian distribution. It is flexible but limited in describing tail dependence.</li>
<li><strong>Student’s t-Copula:</strong> Also elliptical, but introduces symmetric tail dependence. This is a step forward, but it still may not capture certain asymmetric or other nuanced dependencies.</li>
</ul>
<p>Now we move to Archimedean copulas, which depart from the elliptical construction and instead rely on a generating function to encapsulate dependence.</p>
</section>
<section id="the-core-idea-generator-functions" class="level2">
<h2 class="anchored" data-anchor-id="the-core-idea-generator-functions">The Core Idea: Generator Functions</h2>
<p>At the heart of every Archimedean copula lies a <em>generator function</em>, often denoted by <span class="math inline">\(\varphi\)</span>. The Archimedean copula for a pair of variables <span class="math inline">\((U, V)\)</span>—where <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are uniform random variables on [0,1]—can be represented as:</p>
<p><span class="math display">\[
C(u, v) = \varphi^{-1}\big(\varphi(u) + \varphi(v)\big),
\]</span></p>
<p>where <span class="math inline">\(\varphi: [0,1] \to [0, \infty]\)</span> is a continuous, strictly decreasing function with <span class="math inline">\(\varphi(1) = 0\)</span>. The inverse <span class="math inline">\(\varphi^{-1}\)</span> maps from <span class="math inline">\([0, \infty]\)</span> back to [0,1]. Intuitively, <span class="math inline">\(\varphi\)</span> transforms the unit interval into a positive half-line in such a way that “combining” two transformed variables via addition, and then transforming back, yields a valid joint distribution function.</p>
<section id="key-properties-of-the-generator" class="level3">
<h3 class="anchored" data-anchor-id="key-properties-of-the-generator">Key Properties of the Generator</h3>
<ol type="1">
<li><p><strong>Strict Monotonicity and Decreasing Nature:</strong><br>
The function <span class="math inline">\(\varphi\)</span> must be strictly decreasing. This ensures a well-defined inverse <span class="math inline">\(\varphi^{-1}\)</span>.</p></li>
<li><p><strong>Normalization at 1:</strong><br>
We require <span class="math inline">\(\varphi(1)=0\)</span>. This sets a reference point that ensures the copula behaves properly at the boundaries (e.g., when <span class="math inline">\(u\)</span> or <span class="math inline">\(v\)</span> is 1).</p></li>
<li><p><strong>Infinite-Domain Extension:</strong><br>
As <span class="math inline">\(u \to 0\)</span>, <span class="math inline">\(\varphi(u)\)</span> should typically go to <span class="math inline">\(\infty\)</span>, reflecting the tail behavior embedded in the copula structure.</p></li>
</ol>
<p>Many well-known Archimedean copulas (Clayton, Gumbel, Frank) differ only in the choice of <span class="math inline">\(\varphi\)</span>. This simplicity—capturing all dependence through a single function—makes Archimedean copulas a natural and elegant choice for modeling certain types of association that are challenging for elliptical copulas.</p>
</section>
</section>
<section id="from-generators-to-copulas-a-construction" class="level2">
<h2 class="anchored" data-anchor-id="from-generators-to-copulas-a-construction">From Generators to Copulas: A Construction</h2>
<p>To see how this construction emerges, consider the following steps:</p>
<ol type="1">
<li><p><strong>Define <span class="math inline">\(\varphi\)</span>:</strong> Start with a function <span class="math inline">\(\varphi\)</span> that meets the conditions described above.</p></li>
<li><p><strong>Construct a Joint Distribution:</strong> For a bivariate setting, the copula is given by: <span class="math display">\[
C(u,v) = \varphi^{-1}\big(\varphi(u)+\varphi(v)\big).
\]</span></p></li>
<li><p><strong>Extend to Higher Dimensions:</strong> One of the beauties of Archimedean copulas is their straightforward extension to dimensions beyond two. For a <span class="math inline">\(d\)</span>-dimensional Archimedean copula, we have: <span class="math display">\[
C(u_1, u_2, \ldots, u_d) = \varphi^{-1}\big(\varphi(u_1) + \varphi(u_2) + \cdots + \varphi(u_d)\big).
\]</span></p></li>
</ol>
<p>This scalar-additive structure sets them apart: while elliptical copulas rely on a correlation or covariance structure in a multivariate distribution, Archimedean copulas depend on a single function and simple addition of its transformed coordinates.</p>
</section>
<section id="connection-to-laplace-transforms" class="level2">
<h2 class="anchored" data-anchor-id="connection-to-laplace-transforms">Connection to Laplace Transforms</h2>
<p>One of the most profound theoretical insights into Archimedean copulas is their close relationship to <em>Laplace transforms.</em> Indeed, the function <span class="math inline">\(\varphi\)</span> can often be viewed as a Laplace transform of a certain nonnegative random variable. More specifically, there is a well-known representation from survival analysis and risk theory:</p>
<ul>
<li><p>Suppose we have a random variable <span class="math inline">\(T \ge 0\)</span>. Consider its Laplace transform: <span class="math display">\[
\mathcal{L}_T(s) = E[e^{-sT}].
\]</span></p>
<p>If we identify <span class="math inline">\(\varphi(u)\)</span> with <span class="math inline">\(\mathcal{L}_T^{-1}(u)\)</span> for an appropriately chosen random variable <span class="math inline">\(T\)</span>, the Archimedean copula structure emerges naturally. This is not just a mathematical curiosity: it provides deep intuition. The Archimedean construction can be understood as if one is modeling dependent events (or lifetimes) through a latent factor <span class="math inline">\(T\)</span>. Conditional on <span class="math inline">\(T=t\)</span>, the variables become independent, but marginalizing over <span class="math inline">\(T\)</span> induces the copula dependence structure.</p></li>
</ul>
<p>This connection to Laplace transforms is not merely aesthetic—it informs properties such as tail dependence and how the copula behaves under scaling. Furthermore, viewing <span class="math inline">\(\varphi\)</span> through the lens of Laplace transforms can guide us in choosing suitable generators with desirable theoretical properties, like tail heaviness or asymmetry.</p>
</section>
<section id="theoretical-foundations-for-implementation-in-stan" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-foundations-for-implementation-in-stan">Theoretical Foundations for Implementation in Stan</h2>
<p>As we move towards implementation in Stan, it’s helpful to understand the theoretical underpinnings that will guide our coding strategies. Here are some key points:</p>
<ol type="1">
<li><p><strong>Parameterization:</strong><br>
Each Archimedean copula family is characterized by one or more parameters that define <span class="math inline">\(\varphi\)</span>. For example, the Clayton copula has a single parameter <span class="math inline">\(\theta &gt; 0\)</span> that controls the strength of association and tail dependence. Identifying stable parameterizations suitable for HMC sampling will be crucial.</p></li>
<li><p><strong>Differentiability and Inverses:</strong><br>
Stan relies on differentiable functions for efficient Hamiltonian Monte Carlo. Ensuring that <span class="math inline">\(\varphi\)</span> and <span class="math inline">\(\varphi^{-1}\)</span> are differentiable with respect to both parameters and the input variables is key. In practice, this means choosing smooth parameterizations or using stable numerical techniques for the inverse function.</p></li>
<li><p><strong>Boundary Behavior and Numerical Stability:</strong><br>
For certain parameter settings, the behavior of <span class="math inline">\(\varphi\)</span> near <span class="math inline">\(u=1\)</span> or near <span class="math inline">\(u=0\)</span> can cause numerical issues. Implementing safe checks, well-chosen transforms, or robust initializations will help ensure stable sampling.</p></li>
<li><p><strong>Dimensional Extensions:</strong><br>
Moving from bivariate to multivariate is straightforward in theory, but may lead to increased computational complexity. The addition inside <span class="math inline">\(\varphi^{-1}\)</span> grows linearly with dimension, which may be simpler than dealing with large covariance matrices (as in Gaussian copulas). However, careful coding is still necessary for efficient computation.</p></li>
</ol>
</section>
<section id="a-look-ahead" class="level2">
<h2 class="anchored" data-anchor-id="a-look-ahead">A Look Ahead</h2>
<p>In the upcoming posts, we’ll dive into specific Archimedean copula families and show how to implement them in Stan. Each of these copulas—Clayton, Gumbel, and Frank—embodies a different flavor of dependence:</p>
<ul>
<li><strong>Clayton Copula:</strong> Exhibits <em>lower tail dependence</em>, making it suitable for scenarios where joint extreme lows occur more frequently than would be expected under independence.</li>
<li><strong>Gumbel Copula:</strong> Emphasizes <em>upper tail dependence</em>, capturing scenarios where joint extreme highs are more prevalent.</li>
<li><strong>Frank Copula:</strong> Offers a <em>symmetric dependence</em> structure that can be an alternative to Gaussian or Student’s t copulas, useful especially when you want something non-elliptical but still without pronounced tail asymmetry.</li>
</ul>
<p>By understanding their generating functions <span class="math inline">\(\varphi\)</span>, we can tailor copula models to the dependence patterns we observe in our data, and do so in a way that is relatively direct to implement in Stan.</p>
<hr>
<p><strong>In Summary:</strong></p>
<p>Archimedean copulas present a fundamentally different approach to capturing dependence. Rather than building upon multivariate distributions (as with elliptical copulas), they rely on a single univariate function—the generator <span class="math inline">\(\varphi\)</span>—to shape the joint behavior. This approach offers flexibility, conceptual clarity, and direct links to underlying latent structures via Laplace transforms. These theoretical underpinnings will guide our forthcoming exploration and implementations in Stan, as we continue to expand our toolkit for modeling complex dependencies.</p>
<p>In the next post, we’ll pick up one of the most famous Archimedean copulas—the Clayton copula—and implement it step-by-step in Stan, highlighting both theoretical considerations and practical modeling tips. Stay tuned!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.bggj\.is");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>