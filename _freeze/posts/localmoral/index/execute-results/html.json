{
  "hash": "0e4d4d0d39e8bc06076bbd88853b2a93",
  "result": {
    "markdown": "---\ntitle: \"Spatially Dependent Generalized Extreme Value Parameters\"\nsubtitle: \"Using Stan to fit a Generalized Extreme Value Distribution with spatially dependent parameters\"\ndescription: |\n  For my PhD modeling I need to model maximum precipitation data on a large grid. Each location has four parameters in our GEV distribution: location, scale, shape and trend. Here I will write up and do my best to explain a Stan program that puts spatial dependence on these parameters using a BYM2 prior based on each locations neighbors.\nauthor: \n    -   name: \"Brynjólfur Gauti Guðrúnar Jónsson\"\n        url: \"bggj.is\"\n        affiliation: \"Tölfræði, Raunvísindadeild Háskóla Íslands\"\n        affiliation-url: \"https://www.hi.is/tolfraedi_0\"\ndate: \"2023/12/07\"\nformat: \n    html:\n        toc: true\n        toc-location: left\n        code-overflow: scroll\nexecute: \n  echo: true\n  warning: false\ncode-fold: show\neditor: source\ntheme: flatly\ntitle-block-banner: true\nimage: Figures/spatial_gamma.png\ncategories:\n    - english\n    - R\n    - phd\n    - stan\n    - bayesian\n    - spatial statistics\n    - hierarchical modeling\n---\n\n\n**Note:** I'm still working on this post, but I thought I might put it out there while I work on it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bggjphd)\nlibrary(tidyverse)\nlibrary(progressr)\nlibrary(glue)\nlibrary(here)\nlibrary(gt)\nlibrary(future)\nlibrary(progressr)\nlibrary(sf)\nlibrary(mapview)\nlibrary(spdep)\nlibrary(tmap)\ntheme_set(theme_bggj())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstations <- bggjphd::stations |> \n  filter(\n    between(proj_x, 50, 150),\n    between(proj_y, 100, 200)\n  )\n\nprecip <- bggjphd::precip |> \n  semi_join(\n    stations,\n    by = join_by(station)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhandlers(\"cli\")\nplan(multisession, workers = 4)\nwith_progress({\n  station_estimates <-  ms_max(data = precip)\n})\nplan(sequential)\n\nstation_estimates |> \n  qs::qsave(\"data/station_estimates.qs\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstation_estimates <- qs::qread(\"data/station_estimates.qs\") |> \n  select(-hess) |> \n  unnest(par) |> \n  pivot_wider()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_x <- length(unique(stations$proj_x))\nn_y <- length(unique(stations$proj_y))\nd <- stations |> \n  stations_to_sf() |> \n  points_to_grid(n_x = n_x, n_y = n_y) |> \n  inner_join(station_estimates, by = join_by(station))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnb <- poly2nb(d, queen = TRUE)\nnbw <- nb2listw(nb, style = \"W\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_local_moran_plot <- function(variable) {\n  lmoran <- localmoran(\n    d[[variable]], nbw, alternative = \"greater\"\n  )\n  \n  d$lmI <- lmoran[, \"Ii\"] # local Moran's I\n  d$lmZ <- lmoran[, \"Z.Ii\"] # z-scores\n  # p-values corresponding to alternative greater\n  d$lmp <- lmoran[, \"Pr(z > E(Ii))\"]\n  \n  p1 <- tm_shape(d) +\n    tm_polygons(\n      fill = variable, \n      fill.legend = tm_legend(\n        title = variable, \n        style = \"quantile\"\n      ),\n      lwd = 0\n    )\n  \n  p2 <- tm_shape(d) +\n    tm_polygons(\n      fill = \"lmI\",\n      style = \"quantile\",\n      fill.legend = tm_legend(\n        title = \"Local Moran's I\"\n      ),\n      lwd = 0\n    ) +\n    tm_layout(legend.outside = TRUE)\n  \n  p3 <- tm_shape(d) +\n    tm_polygons(\n      fill = \"lmZ\", \n      breaks = c(-Inf, 1.65, Inf),\n      fill.legend = tm_legend(\n        title = \"Z-score\"\n      ),\n      lwd = 0\n    ) +\n    tm_layout(legend.outside = TRUE)\n  \n  p4 <- tm_shape(d) +\n    tm_polygons(\n      fill = \"lmp\", \n      breaks = c(-Inf, 0.05, Inf),\n      fill.legend = tm_legend(\n        title = \"p-value\"\n      ),\n      lwd = 0\n    ) +\n    tm_layout(legend.outside = TRUE)\n  \n  tmap_arrange(p1, p2, p3, p4)\n}\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\np_psi <- make_local_moran_plot(\"psi\")\np_psi\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=100%}\n:::\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\np_tau <- make_local_moran_plot(\"tau\")\np_tau\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=100%}\n:::\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\np_phi <- make_local_moran_plot(\"phi\")\np_phi\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=100%}\n:::\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\np_gamma <- make_local_moran_plot(\"gamma\")\np_gamma\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=100%}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}