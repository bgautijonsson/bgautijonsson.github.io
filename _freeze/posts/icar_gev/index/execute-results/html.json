{
  "hash": "1ded17d10c9bb0055443bea74e281f2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatially Dependent Generalized Extreme Value Parameters\"\nsubtitle: \"Using Stan to fit a Generalized Extreme Value Distribution with spatially dependent parameters\"\ndescription: |\n  For my PhD modeling I need to model maximum precipitation data on a large grid. Each location has four parameters in our GEV distribution: location, scale, shape and trend. Here I will write up an do my best to explain a Stan program that puts spatial dependence on these parameters using an instrinsic conditional autoregression prior based on each locations neighbors.\nauthor: \n    -   name: \"Brynjólfur Gauti Guðrúnar Jónsson\"\n        url: \"bggj.is\"\n        affiliation: \"Tölfræði, Raunvísindadeild Háskóla Íslands\"\n        affiliation-url: \"https://www.hi.is/tolfraedi_0\"\ndate: \"2023/11/21\"\nbibliography: references.bib\nformat: \n    html:\n        toc: true\n        toc-location: left\n        code-overflow: scroll\nexecute: \n  echo: true\n  warning: false\n  eval: false\ncode-fold: show\neditor: source\ntheme: flatly\ntitle-block-banner: true\nimage: Figures/spatial_gamma.png\ncategories:\n    - english\n    - R\n    - phd\n    - stan\n    - bayesian\n    - spatial statistics\n    - hierarchical modeling\n---\n\n\n**Note:** I'm still working on this post, but I thought I might put it out there while I work on it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bggjphd)\nlibrary(tidyverse)\nlibrary(cmdstanr)\nlibrary(posterior)\nlibrary(bayesplot)\nlibrary(progressr)\nlibrary(future)\nlibrary(glue)\nlibrary(skimr)\nlibrary(here)\nlibrary(gt)\ntheme_set(theme_bggj())\n```\n:::\n\n\n# Introduction\n\nMy PhD research is mostly about three things:\n\n-   Extreme Value Statistics\n-   Spatial Statistics\n-   Copulas\n\nIn this post I will write a little about the first two. \n\n## Extreme Value Statistics\n\nUp until now I have mostly been working with the generalized extreme value distribution. The cumulative distribution function of the Generalized Extreme Value distribution is\n\n$$\n\\mathrm{GEV}(y \\vert \\mu, \\sigma, \\xi) = \\begin{cases}\n\\begin{aligned}\n&e^{- \\left(1 + \\xi \\frac{y - \\mu}{\\sigma}\\right)_+^{-1/\\xi}}, \\quad &\\xi \\neq 0 \\\\\n&e^{-e^{- \\frac{y - \\mu}{\\sigma}}}, \\qquad &\\xi = 0\n\\end{aligned}\n\\end{cases}\n$$\n\nThe log-likelihood of the GEV distribution is\n\n$$\n\\ell(\\mu, \\sigma, \\xi) = - n\\log\\sigma - (1 + \\frac{1}{\\xi})\n$$\n\nInstead of $\\mu$ I will be using the parameter $\\mu_t$ where\n\n$$\n\\mu_t = \\mu_0 \\cdot (1 + \\Delta(t - t_0)) = \\mu_0 + \\Delta(t - t_0) \\cdot \\mu_0.\n$$\n\nThis gives us to paramters to estimate, $\\mu_0$ and $\\Delta$.\n\n## Spatial Statistics\n\nIn our formulation, the GEV distribution has four parameters:\n\n-   $\\mu$: Location\n-   $\\sigma$: Scale\n-   $\\xi$: Shape\n-   $\\Delta$: Trend\n\nYou could also just say that there are three parameters and that we're using a linear model to allow a trend in the location parameter, but we'll keep this wording for now.\n\nI will be fitting a GEV distribution to each area in the [CEDA Archived data I've written about before](https://bggj.is/posts/ceda-archive/). It's logical to assume that these areas are not completely independent and that there is some sort of spatial dependency, i.e. that all other things being equal; areas that are near each other are more similar that areas that are far away from each other.\n\nWe could apply a model structure based on the distance between points, but we will end up having a lot of areas *(around 40,000 or so)*, so we need a spatial model that allows for sparsity in the spatial dependence.\n\nOne way to do this is to model the areas as jointly multivariate normal distributed with a sparse precision matrix. Precision matrices can be better than covariance matrices for this type of modeling since the off-diagonal elements in a precision matrix stand for conditional dependencies.\n\nMore formally, let $\\mathbf x$ be multivariate normal distributed with mean $\\boldsymbol \\mu$ and semi positive definite precision matrix $\\mathbf Q$. Then for $i \\neq j$\n\n$$\nx_i \\perp x_j \\vert \\mathbf x_{-ij} \\iff Q_{ij} = 0.\n$$\n\nThis means that any two elements in $\\mathbf x$ are conditionally independent conditional on the other elements of $\\mathbf x$ if and only if the corresponding value in the precision matrix $\\mathbf Q$ is zero.\n\nWe can easily use this to our advantage so that our precision matrix becomes very sparse. For example we might set $Q_{ij} \\neq 0$ only if $i$ and $j$ are neighbors on our map.\n\nThe rest of this chapter on spatial statistics is based heavily on the paper by @morrisBayesianHierarchicalSpatial2019.\n\n### Conditional Autoregression (CAR) Models\n\nIn a CAR prior, the prior distribution of $x_i$ given its neighbors can be written\n\n$$\nx_i \\vert x_{-i} \\sim \\mathrm{Normal}\\left( \\sum_{j\\in S_i} w_{ij}x_j, \\sigma^2 \\right),\n$$\n\nwhere $x_{-i}$ means every element of $x$ except for $x_i$, $S_i$ is the set of neighbors of $x_i$, and $w_{ij}$ are weights.\n\nThis can be written as a multivariate normal variate with mean 0 and a precision matrix, $\\mathbf Q$, which is defined as\n\n$$\nQ = D(I - \\alpha A).\n$$\n\nHere, D is a diagonal matrix with $D_{ii} = d_i$ being equal to the number of neighbors of $x_i$, $A$ is the adjacency matrix \n\n$$\nA_{ij} = 1 \\iff x_j \\in S_i,\n$$\n\n$I$ is the identity matrix, and $0 < \\alpha < 1$ is a parameter that encodes the amount of spatial dependence. If $\\alpha = 0$ then there is no spatial dependence and if $\\alpha = 1$ we get what is called an ICAR model.\n\n\n### Intrinsic Conditional Autoregression (ICAR) Models\n\nIn an ICAR model the spatial dependence parameter $\\alpha = 1$ and so, the precision matrix, $Q$, is singular since then\n\n$$\nQ = D(I - A).\n$$\n\nRecall that $D_{ii} = d_i$ is equal to the number of neighbors of $x_i$ and so the diagonal of $Q$ will be equal to the sum of its off-diagonal elements. This can still be used as a prior, but we must take care since it is an improper prior. \n\nThe conditional distribution of $x_i$ given all other observations is\n\n$$\nx_i \\vert x_{-i} \\sim \\mathrm{Normal}\\left( \\frac{ \\sum_{j\\in S_i}{x_j}}{d_i}, \\frac{\\sigma_i^2}{d_i}\\right).\n$$\n\nIf we specify that $x$ as mean 0 and variance 1, then the joint distribution of $x$ becomes\n\n$$\nx \\sim \\exp\\left(-\\frac12 \\sum_{j\\in S_i}{(x_i - x_j)^2}\\right).\n$$\n\nWe can easily see that this is not proper, since any constant added to all of the $x_i$'s will give the same density. One way around this issue is to add the constraint $\\sum x_i = 0$.\n\n### Besag York Mollié (BYM) Model\n\nThe BYM model is composed of two different types of random effects:\n\n* An ICAR component $\\phi$\n* An iid non-spatial component $\\theta$\n\nHere, both $\\phi$ and $\\theta$ are assumed to follow normal distributions with means 0  and precision parameters $\\tau_\\phi$ and $\\tau_\\theta$. We can see that if $\\tau_\\phi$ is estimated to be much higher than $\\tau_\\theta$ then our data is implying more spatial than non-spatial dependence *(and vice versa)*. \n\nOne difficulty in using this model is that apriori we want *\"fair\"* hyperpriors for the precision parameters, i.e. we do not want our prior to weight our model in the direction of more or less spatial dependence. One way to choose these priors is the formula from [@lBayesianEstimatesDisease1995]:\n\n\n\n$$\nsd(\\theta_i) = \\frac{1}{\\sqrt{\\tau_\\phi}} \\approx \\frac{1}{0.7\\sqrt{\\bar m \\tau_\\theta}} \\approx sd(\\phi_i),\n$$\n\nwhere $\\bar m$ is the average number of neighbors for each $x_i$.\n\n### BYM2 Model\n\nThe BYM2 model [@rieblerIntuitiveBayesianSpatial2016] rewrites the hyperpriors from the BYM model in a way that follows the *Penalized Complexity Priors* framework [@simpsonPenalisingModelComponent2015]. The prior is rewritten so that a single scale parameter, $\\sigma$, determines the variance of both components, and a mixing parameter, $\\rho$, determines the amount of spatial/non-spatial random effect.\n\nThe combined effects, $\\phi + \\theta$, are thus rewritten as\n\n$$\n\\left( \\sqrt{\\rho} \\cdot \\frac{\\phi^*}{\\sqrt s} + \\sqrt{1 - \\rho} \\cdot\\theta^* \\right),\n$$\nwhere $0 \\leq \\rho \\leq 1$ determines the amount of spatial/non-spatial error, $\\phi^*$ is the ICAR model, $\\theta^*$ is an iid random effect, $s$ is the scaling factor for the neighborhood graph, $\\sigma \\geq 0$ is the overall standard deviation of the combined random effects.\n\n## Copulas\n\nEven if we use the aforementioned models to allow spatial dependence between the paremeters in our GEV distributions, there is still one problem: We're not modeling spatial distributions on the data level.\n\nThis means that our model as it is currently set up can allow spatial dependence in how often extreme precipitation happens in neighboring regions, but it does not allow for spatial dependence in when we observe extreme precipitation. To do this, we will need to apply copulas. I will not write about them here, but I have a post on the way about applying copulas to data with GEV margins.\n\n\n# Data\n\nThe data used in this research are downloaded from the CEDA Archive:\n\n* [UKCP Local Projections on a 5km grid over the UK for 1980-2080](https://data.ceda.ac.uk/badc/ukcp18/data/land-cpm/uk/5km)\n\nThe raw data contain climate projections for the UK on a 5km grid from 1980 to 2080 for a high emissions scenario, *RCP8.5*, and contain hourly precipitation rates of $43.920$ squares on a $180 \\times 244$ grid. The projections are calculated for $1980 - 2000$, $2020 - 2040$, and $2060 - 2080$, thus giving $60 \\times 365 \\times 24 \\times 180 \\times 244 \\approx 2.3 \\cdot 10^{10}$ data points. \n\nThe raw data were processed by calculating the yearly maximum over the hourly precipitation rates for each station, thus reducing the number of data points to $60 \\times 180 \\times 244 \\approx 2.6 \\cdot 10^6$.\n\nFor a description of how to download the data, see my post on [Fetching FTP data from the Ceda Archives](https://bggj.is/posts/ceda-archive/).\n\n## Subset of the data\n\nFor this analysis, I will be subsetting the data to save time. I'm going to use 10.201 stations with X projections between 50 and 150, and Y projections between 100 and 200.\n\n### Stations\n\nTo be able to index the stations in my Stan program, I give the stations new names according to their row number. In the filtered dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_stations <- stations |>\n  filter(\n    between(proj_x, 50, 150),\n    between(proj_y, 100, 200)\n  )\n\nnew_names <- model_stations |> \n  mutate(new_name = row_number()) |> \n  distinct(station, new_name)\n\nmodel_stations |> \n  skim()\n```\n:::\n\n\n### Precipitation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_precip <- precip |>\n  semi_join(\n    model_stations,\n    by = join_by(station)\n  )\n\nmodel_precip |> \n  skim()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- model_precip |> \n  filter(\n    station %in% sample(station, size = 3)\n  ) |> \n  mutate(\n    period = 1 + (year >= 2020) + (year >= 2060),\n    period = c(\"1980 - 2000\", \"2020 - 2040\", \"2060 - 2080\")[period],\n    station = str_c(\"Station\\n\", station)\n  ) |> \n  ggplot(aes(year, precip)) +\n  geom_point() +\n  geom_segment(\n    aes(\n      yend = 0, xend = year\n    ),\n    lty = 2,\n    alpha = 0.5,\n    linewidth = 0.6\n  ) +\n  facet_grid(\n    cols = vars(period),\n    rows = vars(station),\n    scales = \"free_x\"\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"An example of extreme value observations\",\n    subtitle = \"Annual values of maximum daily precipitation for a sample of stations in the data\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/ts_extreme_plot.png\",\n  width = 8, height = 0.621 * 8, scale = 1.3\n)\n```\n:::\n\n\n![](Figures/ts_extreme_plot.png){.column-page}\n\n## Prepare the data for Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprecip_matrix <- model_precip |>\n  pivot_wider(names_from = station, values_from = precip) |>\n  column_to_rownames(\"year\") |>\n  as.matrix()\n\nN_stations <- ncol(precip_matrix)\nN_years <- nrow(precip_matrix)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_names <- function(table, variable) {\n  table |> \n    inner_join(\n      new_names,\n      by = join_by({{ variable }} == station)\n    ) |> \n    mutate(\n      \"{{variable}}\" := new_name\n    ) |> \n    select(-new_name)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nedges <- twelve_neighbors |>\n  filter(\n    type %in% c(\"e\", \"n\", \"w\", \"s\")\n  ) |>\n  inner_join(\n    model_stations,\n    by = join_by(station)\n  ) |>\n  semi_join(\n    model_stations,\n    by = join_by(neighbor == station)\n  ) |>\n  select(station, neighbor) |> \n  update_names(station) |> \n  update_names(neighbor)\n\nN_neighbors = nrow(edges)\nnode1 <- edges$station\nnode2 <- edges$neighbor\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_data <- list(\n  N_stations = N_stations,\n  N_years = N_years,\n  precip = precip_matrix,\n  N_neighbors = N_neighbors,\n  node1 = node1,\n  node2 = node2\n)\n```\n:::\n\n\n# Model\n\nThe model is written below in math and Stan code.\n\n::: {.panel-tabset}\n\n## Math\n\n$$\n\\begin{gathered}\ny_{it} \\sim \\mathrm{GEV}(\\mu_{it}, \\sigma_i, \\xi_i) \\\\\n\\mu_{it} = \\mu_i^0 \\cdot(1 + \\Delta_i (t - t_0)) \\\\\n\\begin{pmatrix}\n\\psi_i \\\\ \\tau_i \\\\ \\phi_i \\\\ \\gamma_i\n\\end{pmatrix} = \n\\begin{pmatrix}\n\\log(\\mu_{i}^0) \\\\ \n\\log(\\sigma_i) - \\psi_i \\\\\nf_\\phi(\\xi) \\\\\nf_\\gamma(\\Delta)\n\\end{pmatrix} \\\\\n\\psi \\sim \\mathrm{Normal}(\\mu_\\psi, \\sigma_\\psi^*) \\quad\n\\sigma_\\psi^* \\sim \\mathrm{BYM2}_\\psi(\\sigma_\\psi, \\rho_\\psi) \\\\\n\\tau \\sim \\mathrm{Normal}(\\mu_\\tau, \\sigma^*_\\tau) \\quad\n\\sigma^*_\\tau \\sim \\mathrm{BYM2}_\\tau(\\sigma_\\tau, \\rho_\\tau) \\\\\n\\phi \\sim \\mathrm{Normal}(\\mu_\\phi, \\sigma^*_\\phi) \\quad\n\\sigma^*_\\phi \\sim \\mathrm{BYM2}_\\phi(\\sigma_\\phi, \\rho_\\phi) \\\\\n\\gamma \\sim \\mathrm{Normal}(\\mu_\\gamma, \\sigma^*_\\gamma) \\quad\n\\sigma^*_\\gamma \\sim \\mathrm{BYM2}_\\gamma(\\sigma_\\gamma, \\rho_\\gamma) \\\\\n\\sigma_\\psi, \\sigma_\\tau, \\sigma_\\phi, \\sigma_\\gamma \\sim \\mathrm{Exponential}(1) \\\\\n\\mathrm{logit}(\\rho_\\phi), \\dots, \\mathrm{logit(\\rho_\\gamma)} \\sim \\mathrm{Normal}(0, 1)\n\\end{gathered}\n$$\n\n## Stan\n\n\n::: {.cell output.var='model'}\n\n```{.stan .cell-code}\n\nfunctions{\n  /*\n  Fit a GEV distribution with trend\n  */\n  real gevt_lpdf(vector y, real mu0, real sigma, real xi, real delta) {\n    int N = rows(y);\n    vector[N] z;\n    vector[N] mu;\n    real lp = 0;\n\n    for (i in 1:N) {\n      mu[i] = mu0 * (1 + delta * (i - 1));\n\n      if (z[i] <= -1) {\n        reject(\"found incompatible variable values\");\n      }\n      \n      if (abs(xi) < 1e-12) {\n        z[i] = (y[i] - mu[i]) / sigma;\n        lp += - z[i] - exp(-z[i]);\n      } else {\n        z[i] = xi * (y[i] - mu[i]) / sigma;\n        lp += - (1 + 1 / xi) * log(1 + z[i]) - pow((1 + z[i]), -1/xi);\n      }\n    }\n\n    lp += -N * log(sigma);\n\n    return lp;\n  }\n  /*\n  Put an ICAR prior on coefficients\n  */\n  real icar_normal_lpdf(vector phi, int N, array[] int node1, array[] int node2) {\n    return - 0.5 * dot_self((phi[node1] - phi[node2])) \n      + normal_lpdf(sum(phi) | 0, 0.001 * N);\n  }\n}\n\ndata {\n  int<lower = 0> N_years;\n  int<lower = 0> N_stations;\n  matrix[N_years, N_stations] precip;\n\n\n  int<lower = 0> N_neighbors;\n  array[N_neighbors] int node1;\n  array[N_neighbors] int node2;\n}\n\n\n\nparameters {\n  vector[N_stations] psi_random;\n  vector[N_stations] psi_spatial;\n  real<lower = 0> sigma_psi;\n  real mu_psi;\n  real logit_rho_psi;\n  \n  vector[N_stations] tau_random;\n  vector[N_stations] tau_spatial;\n  real<lower = 0> sigma_tau;\n  real mu_tau;\n  real logit_rho_tau;\n  \n  vector[N_stations] phi_random;\n  vector[N_stations] phi_spatial;\n  real<lower = 0> sigma_phi;\n  real mu_phi;\n  real logit_rho_phi;\n  \n  vector[N_stations] gamma_random;\n  vector[N_stations] gamma_spatial;\n  real<lower = 0> sigma_gamma;\n  real mu_gamma;\n  real logit_rho_gamma;\n}\n\ntransformed parameters {\n  real<lower = 0, upper = 1> rho_psi = inv_logit(logit_rho_psi);\n  real<lower = 0, upper = 1> rho_tau = inv_logit(logit_rho_tau);\n  real<lower = 0, upper = 1> rho_phi = inv_logit(logit_rho_phi);\n  real<lower = 0, upper = 1> rho_gamma = inv_logit(logit_rho_gamma);\n  \n  vector[N_stations] psi = mu_psi + sigma_psi * (sqrt(rho_psi) * psi_spatial + sqrt(1 - rho_psi) * psi_random);\n  vector[N_stations] tau = mu_tau + sigma_tau * (sqrt(rho_tau) * tau_spatial + sqrt(1 - rho_tau) * tau_random);\n  vector[N_stations] phi = mu_phi + sigma_phi * (sqrt(rho_phi) * phi_spatial + sqrt(1 - rho_phi) * phi_random);\n  vector[N_stations] gamma = mu_gamma + sigma_gamma * (sqrt(rho_gamma) * gamma_spatial + sqrt(1 - rho_gamma) * gamma_random);\n  \n  vector<lower = 0>[N_stations] mu0 = exp(psi);\n  vector<lower = 0>[N_stations] sigma = exp(psi + tau);\n  vector<lower = -0.5, upper = 0.5>[N_stations] xi = 0.5 * inv_logit(phi);\n  vector<lower = -0.008, upper = 0.008>[N_stations] delta = 0.008 * inv_logit(gamma);\n}\n\nmodel {\n  for (i in 1:N_stations) {\n    precip[ , i] ~ gevt(mu0[i], sigma[i], xi[i], delta[i]);\n  }\n\n  psi_spatial ~ icar_normal(N_neighbors, node1, node2);\n  psi_random ~ std_normal();\n  sigma_psi ~ exponential(1);\n  logit_rho_psi ~ std_normal();\n  mu_psi ~ normal(2.2, 1);\n  \n  tau_spatial ~ icar_normal(N_neighbors, node1, node2);\n  tau_random ~ std_normal();\n  sigma_tau ~ exponential(1);\n  logit_rho_tau ~ std_normal();\n  mu_tau ~ normal(-0.9, 1);\n  \n  phi_spatial ~ icar_normal(N_neighbors, node1, node2);\n  phi_random ~ std_normal();\n  sigma_phi ~ exponential(1);\n  logit_rho_phi ~ std_normal();\n  mu_phi ~ normal(0, 1);\n  \n  gamma_spatial ~ icar_normal(N_neighbors, node1, node2);\n  gamma_random ~ std_normal();\n  sigma_gamma ~ exponential(1);\n  logit_rho_gamma ~ std_normal();\n  mu_gamma ~ normal(0, 1);\n\n}\n```\n:::\n\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_file <- here(\"posts\", \"icar_gev\", \"Stan\", \"BYM_GEV_LOGIT.stan\")\n\nmod <- cmdstan_model(model_file)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- mod$sample(\n  data = stan_data,\n  chains = 4,\n  parallel_chains = 4,\n  refresh = 100,\n  # init = 0,\n  iter_warmup = 1000, \n  iter_sampling = 1000,\n  output_dir = here(\"posts\", \"icar_gev\", \"Stan\", \"Draws\")\n)\n\nfit$save_object(file = \"Stan/Model_Objects/fit.RDS\")\n```\n:::\n\n\n# Results\n\nI won't show convergence analytics here, but after doing our due diligence we can move on to looking at parameter estimates.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndraws <- fit$draws() |> as_draws_df()\n```\n:::\n\n\n## Pairs Plot for Station 5\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstation_pairs_plot <- function(station, link = TRUE) {\n  if (link == TRUE) {\n    my_pars <- c(glue(\"psi[{station}]\"), glue(\"tau[{station}]\"), glue(\"phi[{station}]\"), glue(\"gamma[{station}]\"))\n  } else {\n    my_pars <- c(glue(\"mu0[{station}]\"), glue(\"sigma[{station}]\"), glue(\"xi[{station}]\"), glue(\"delta[{station}]\"))\n  }\n  \n  \n  draws |>\n    mcmc_pairs(\n      pars = my_pars,\n      off_diag_fun = \"hex\",\n      diag_fun = \"dens\"\n    )\n}\n```\n:::\n\n\n::: {.panel-tabset}\n\n### Unconstrained Scale\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- station_pairs_plot(5)\n\nggsave(\n  plot = p,\n  filename = \"Figures/station_pairs_plot_link.png\",\n  width = 8, height = 1 * 8, scale = 1.3\n)\n```\n:::\n\n\n![Here we see a pairs plot of all four GEV parameters for station 5. The plot is shown on the unconstrained scale.](Figures/station_pairs_plot_link.png){.fig-cap-location-margin}\n\n### Original Scale\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- station_pairs_plot(5, link = FALSE)\n\nggsave(\n  plot = p,\n  filename = \"Figures/station_pairs_plot_no_link.png\",\n  width = 8, height = 1 * 8, scale = 1.3\n)\n```\n:::\n\n\n![Here we see a pairs plot of all four GEV parameters for station 5. The plot is shown on the original scale.](Figures/station_pairs_plot_no_link.png)\n\n\n:::\n\n## Spatial Distribution\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nspatial_plot <- function(variable) {\n  \n  draws |>\n    subset_draws(variable = glue(\"^{variable}\\\\[\"), regex = TRUE) |>\n    summarise_draws() |> \n    mutate(station = parse_number(str_replace(variable, \"mu0\", \"mu\"))) |>\n    inner_join(\n      model_stations |> \n        update_names(station),\n      by = join_by(station)\n    ) |>\n    ggplot(aes(proj_x, proj_y)) +\n    geom_raster(interpolate = F, aes(fill = mean)) +\n    scale_fill_viridis_c() +\n    coord_cartesian(expand = FALSE)\n}\n```\n:::\n\n\n### Location\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- spatial_plot(\"psi\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\psi$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_psi.png\",\n  width = 8, height = 8, scale = 1.3\n)\n\n\np <- spatial_plot(\"mu0\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\mu_0$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_mu0.png\",\n  width = 8, height = 8, scale = 1.3\n)\n```\n:::\n\n\n::: {layout-ncol=2 .column-page}\n![](Figures/spatial_psi.png)\n\n![](Figures/spatial_mu0.png)\n:::\n\n\n### Scale\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- spatial_plot(\"tau\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\tau$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_tau.png\",\n  width = 8, height = 8, scale = 1.3\n)\n\n\np <- spatial_plot(\"sigma\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\sigma$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_sigma.png\",\n  width = 8, height = 8, scale = 1.3\n)\n```\n:::\n\n\n::: {layout-ncol=2 .column-page}\n![](Figures/spatial_tau.png)\n\n![](Figures/spatial_sigma.png)\n:::\n### Shape\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- spatial_plot(\"phi\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\phi$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_phi.png\",\n  width = 8, height = 8, scale = 1.3\n)\n\n\np <- spatial_plot(\"xi\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\xi$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_xi.png\",\n  width = 8, height = 8, scale = 1.3\n)\n```\n:::\n\n\n::: {layout-ncol=2 .column-page}\n![](Figures/spatial_phi.png)\n\n![](Figures/spatial_xi.png)\n:::\n\n### Trend\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- spatial_plot(\"gamma\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\gamma$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_gamma.png\",\n  width = 8, height = 8, scale = 1.3\n)\n\n\np <- spatial_plot(\"delta\")\n\np <- p +\n  labs(\n    x = \"X Projection\",\n    y = \"Y Projection\",\n    fill = \"Posterior mean\"\n  ) +\n  ggtitle(\n    label = latex2exp::TeX(\"Spatial distribution of $\\\\Delta$\")\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_delta.png\",\n  width = 8, height = 8, scale = 1.3\n)\n```\n:::\n\n\n::: {layout-ncol=2 .column-page}\n![](Figures/spatial_gamma.png)\n\n![](Figures/spatial_delta.png)\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}