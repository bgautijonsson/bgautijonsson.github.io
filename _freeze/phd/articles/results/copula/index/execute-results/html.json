{
  "hash": "ce0aedf5ca266a6e5f4ac8cfa34aad7c",
  "result": {
    "markdown": "---\ntitle: \"T-Copula\"\nexecute:\n  eval: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bggjphd)\nlibrary(tidyverse)\nlibrary(progressr)\nlibrary(future)\nlibrary(bayesplot)\nlibrary(GGally)\nlibrary(scales)\nlibrary(cowplot)\nlibrary(kableExtra)\nlibrary(arrow)\nlibrary(tictoc)\nlibrary(broom)\nlibrary(corrr)\nlibrary(patchwork)\ntheme_set(theme_half_open())\n```\n:::\n\n\n# Summary\n\nAt this point we have performed the Max-and-Smooth estimation procedure and obtained samples from the posterior distribution of the location-wise GEV parameters. \n\nIn this analysis we \n\n* use these estimates to obtain posterior predictions of the observed extreme precipitation observations in the form of probability values in the range (0, 1). \n* We then convert these probabilities into t-distributed observations by using the quantile function of the t-distribution with mean 0, variance 1 and degrees-of-freedom 3.\n* Using these t-distributed variables we want to find out how much the observed discrepancies are correlated with the discrepancies of a location's neighbors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- -log(1 - (1/2)^0.5) * (1 - (1/2)^0.5) * 2^(0.5 - 1) / 0.5\na <- -b * log(-log(1 - (1/2)^0.5))\n\npgev <- function(y, loc, scale, shape) {\n  out <- 1 + shape * (y - loc) / scale\n  out <- out ^ (-1/shape)\n  out <- exp(-out)\n  out\n} \n\n#| eval: false\nmcmc <- open_dataset(\"data/posterior_samples.parquet\") |> \n  to_duckdb()\n\ni <- c(0, seq_len(floor(nrow(stations) / 100)))\n\nget_t_vals <- function(idx) {\n  gc()\n  Sys.sleep(0.1)\n  out <- mcmc |> \n    filter(floor(station/100) == idx) |> \n    mutate(\n      mu = exp(psi),\n      sigma = exp(psi + tau),\n      xi =  (1 - exp(-exp((phi - a)/b))) ^ (1 / 0.5) - 1/2,\n      delta = 0.008 * (exp(2 * gamma / 0.008) - 1) / (exp(2 * gamma / 0.008) + 1)\n    ) |> \n    select(chain, iter, station, mu0 = mu, sigma, xi, delta) |> \n    collect() |> \n    inner_join(\n      precip,\n      by = \"station\"\n    ) |> \n    mutate(\n      mu = mu0 * (1 + delta * (year - 1981)),\n      p = pgev(precip, mu, sigma, xi),\n      t_val = qt(p = p, df = 3)\n    ) |> \n    summarise(\n      t_val = mean(t_val, na.rm = TRUE),\n      .by = c(station, year, precip)\n    )\n  \n  out\n}\n\nmcmc_results <- map_dfr(\n  i, \n  get_t_vals\n)\n\nml_results <- station_estimates |> \n  unnest(par) |> \n  select(-hess) |> \n  pivot_wider() |> \n  mutate(\n    mu0 = exp(psi),\n    sigma = exp(psi + tau),\n    xi = link_shape_inverse(phi),\n    delta = link_trend_inverse(gamma)\n  ) |> \n  select(station, mu0:delta) |> \n  inner_join(\n    precip, \n    by = \"station\",\n    multiple = \"all\"\n  ) |> \n  mutate(\n    mu = mu0 * (1 + delta * (year - 1981)),\n    p = pgev(precip, mu, sigma, xi),\n    t_val = qt(p = p, df = 3),\n    model_type = \"ml\"\n  ) |> \n  select(station, year, model_type, t_val)\n\nml_results |> \n  bind_rows(\n    mcmc_results |> \n      mutate(model_type = \"mcmc\") |> \n      select(-precip)\n  ) |> \n  write_parquet(\"data/t_vals.parquet\")\n\n\nrm(ml_results, mcmc_results)\n\nd <- read_parquet(\"data/t_vals.parquet\")\n\ndat <- twelve_neighbors |> \n  inner_join(\n    d |> \n      rename(y = t_val),\n    by = \"station\",\n    multiple = \"all\"\n  ) |> \n  inner_join(\n    d |> \n      rename(x = t_val),\n    by = c(\"neighbor\" = \"station\", \"year\", \"model_type\"),\n    multiple = \"all\"\n  ) |> \n  select(year, model_type, station, neighbor, y, x, type) |> \n  arrange(station, model_type, year, neighbor)\n\ndat |> \n  write_parquet(\"data/neighbor_t_val_data.parquet\")\n\ndat <- read_parquet(\"data/neighbor_t_val_data.parquet\")\n```\n:::\n\n\n\n# Simultaneous estimation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(d)\nresults <- dat |> \n  select(-neighbor) |> \n  pivot_wider(names_from = type, values_from = x) |> \n  group_by(station, model_type) |> \n  group_modify(\n    function(data, ...) {\n      model_dat <- data |> \n        select(\n          -year\n        ) |> \n        select(\n          where(\n            ~ !any(is.na(.x))\n          )\n        ) |> \n        filter(\n          if_all(everything(), is.finite)\n        ) \n      \n      lm(y ~ . - 1, data = model_dat) |> \n        tidy()\n    }\n  ) |> \n  ungroup()\n\nresults |> \n  write_parquet(\n    \"Data/multivariate.parquet\"\n  )\n```\n:::\n\n\n\n## Mean values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultivariate <- read_parquet(\"Data/multivariate.parquet\")\n\nplot_dat <- multivariate |> \n  select(station, model_type, type = term, estimate) |> \n  summarise(\n    mean = mean(estimate),\n    sd = sd(estimate),\n    .by = c(type, model_type)\n  ) |> \n  inner_join(\n    neighbor_types,\n    by = \"type\"\n  ) \n\nmax_est <- max(plot_dat$mean, na.rm = T)\nmin_est <- min(plot_dat$mean, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(-1, 1) * scale_size\n\n\np <- plot_dat |> \n  ggplot(aes(diff_x, diff_y, fill = mean)) +\n  geom_raster() + \n  scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits, direction = 1) +\n  facet_wrap(\"model_type\") +\n  labs(\n    x = NULL,\n    y = NULL\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/mean_neighbor_effect_multivariate.png\",\n  width = 8, height = 0.621 * 8, scale = 1.2,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/mean_neighbor_effect_multivariate.png){.column-page}\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- plot_dat |> \n  select(-sd) |> \n  pivot_wider(names_from = model_type, values_from = mean) |> \n  ggplot(aes(mcmc, ml)) +\n  geom_abline(intercept = 0, slope = 1, lty = 2) +\n  geom_point() +\n  labs(\n    x = \"Neighour effect from spatial model\",\n    y = \"Neighbour effect from ML model\",\n    title = \"Comparison of Mean of neighbour effects in ML and MCMC models\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/compare_mean_neighbor_effect_multivariate.png\",\n  width = 8, height = 0.621 * 8, scale = 1.2,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/compare_mean_neighbor_effect_multivariate.png){.column-page}\n\n\n\n## Spatial Distribution\n\n### Maximum Likelihood\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- multivariate |> \n  filter(model_type == \"ml\") |> \n  select(station, type = term, estimate = statistic) |> \n  mutate(\n    estimate = case_when(\n      estimate > quantile(estimate, 0.995) ~ quantile(estimate, 0.995),\n      estimate < quantile(estimate, 0.005) ~ quantile(estimate, 0.005),\n      TRUE ~ estimate\n    ),\n    .by = type\n  ) |> \n  inner_join(\n    stations,\n    by = \"station\"\n  )\n\n\nmax_est <- max(plot_dat$estimate, na.rm = T)\nmin_est <- min(plot_dat$estimate, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(-1, 1) * scale_size\n\n# plot_dat |>\n#   filter(type == \"ww\") |>\n#   ggplot(aes(proj_x, proj_y, fill = estimate)) +\n#   geom_raster(interpolate = TRUE) +\n#   scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits) +\n#   facet_wrap(\"type\")\n\nplots <- plot_dat |> \n  mutate(term = type) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(proj_x, proj_y, fill = estimate)) +\n                    geom_raster(interpolate = TRUE) +\n                    scale_fill_distiller(\n                      type = \"div\",\n                      palette = \"RdBu\",\n                      limits = limits,\n                      direction = 1\n                    ) +\n                    facet_wrap(\"term\") +\n                    theme_void() +\n                    labs(\n                      fill = \"t-statistic\"\n                    )\n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Spatial distributions of neighbor effects in t-copula (ML Predictions)\",\n    subtitle = \"Shown as t-statistics of linear model coefficients\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_dist_by_neighbor_type_ml.png\",\n  width = 8, height = 8, scale = 1,\n  bg = \"white\",\n  dpi = 320\n)\n```\n:::\n\n\n![](Figures/spatial_dist_by_neighbor_type_ml.png){.column-page}\n\n### Spatial Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- multivariate |> \n  filter(model_type == \"mcmc\") |> \n  select(station, type = term, estimate = statistic) |> \n  mutate(\n    estimate = case_when(\n      estimate > quantile(estimate, 0.995) ~ quantile(estimate, 0.995),\n      estimate < quantile(estimate, 0.005) ~ quantile(estimate, 0.005),\n      TRUE ~ estimate\n    ),\n    .by = type\n  ) |> \n  inner_join(\n    stations,\n    by = \"station\"\n  )\n\n\nmax_est <- max(plot_dat$estimate, na.rm = T)\nmin_est <- min(plot_dat$estimate, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(-1, 1) * scale_size\n\n# plot_dat |>\n#   filter(type == \"ww\") |>\n#   ggplot(aes(proj_x, proj_y, fill = estimate)) +\n#   geom_raster(interpolate = TRUE) +\n#   scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits) +\n#   facet_wrap(\"type\")\n\nplots <- plot_dat |> \n  mutate(term = type) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(proj_x, proj_y, fill = estimate)) +\n                    geom_raster(interpolate = TRUE) +\n                    scale_fill_distiller(\n                      type = \"div\",\n                      palette = \"RdBu\",\n                      limits = limits,\n                      direction = 1\n                    ) +\n                    facet_wrap(\"term\") +\n                    theme_void() +\n                    labs(\n                      fill = \"t-statistic\"\n                    )\n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Spatial distributions of neighbor effects in t-copula (MCMC Predictions)\",\n    subtitle = \"Shown as t-statistics of linear model coefficients\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_dist_by_neighbor_type_mcmc.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/spatial_dist_by_neighbor_type_mcmc.png){.column-page}\n\n## Parameter Correlations\n\n### Maximum Likelihood\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- multivariate |> \n  filter(model_type == \"ml\") |> \n  select(station, type = term, estimate) |> \n  pivot_wider(names_from = type, values_from = estimate) |> \n  ungroup() |> \n  select(-station) |> \n  correlate(method = \"pearson\", use = \"pairwise.complete.obs\", quiet = T) |> \n  pivot_longer(c(-term), names_to = \"term2\", values_to = \"correlation\") |> \n  inner_join(\n    neighbor_types,\n    by = c(\"term2\" = \"type\")\n  )\n\nmax_cor <- max(plot_dat$correlation, na.rm = T)\nmin_cor <- min(plot_dat$correlation, na.rm = T)\nscale_size <- max(abs(max_cor), abs(min_cor), na.rm = T)\nlimits <- c(-1, 1) * scale_size\n\n\n\n\nplots <- plot_dat |> \n  mutate(type = term) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(diff_x, diff_y, fill = correlation)) +\n                    geom_raster() +\n                    # scale_fill_viridis_c(guide = guide_colorbar(), limits = limits) +\n                    scale_fill_distiller(\n                      type = \"div\", \n                      palette = \"RdBu\", \n                      limits = limits,\n                      direction = 1\n                    ) +\n                    facet_wrap(\"term\") +\n                    theme_void() \n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Correlations between effects of different neighbors (ML predictions)\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/neighbor_type_correlations_ml.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/neighbor_type_correlations_ml.png){.column-page}\n\n### Spatial model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- multivariate |> \n  filter(model_type == \"mcmc\") |> \n  select(station, type = term, estimate) |> \n  pivot_wider(names_from = type, values_from = estimate) |> \n  ungroup() |> \n  select(-station) |> \n  correlate(method = \"pearson\", use = \"pairwise.complete.obs\", quiet = T) |> \n  pivot_longer(c(-term), names_to = \"term2\", values_to = \"correlation\") |> \n  inner_join(\n    neighbor_types,\n    by = c(\"term2\" = \"type\")\n  )\n\nmax_cor <- max(plot_dat$correlation, na.rm = T)\nmin_cor <- min(plot_dat$correlation, na.rm = T)\nscale_size <- max(abs(max_cor), abs(min_cor), na.rm = T)\nlimits <- c(-1, 1) * scale_size\n\n\n\n\nplots <- plot_dat |> \n  mutate(type = term) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(diff_x, diff_y, fill = correlation)) +\n                    geom_raster() +\n                    # scale_fill_viridis_c(guide = guide_colorbar(), limits = limits) +\n                    scale_fill_distiller(\n                      type = \"div\", \n                      palette = \"RdBu\", \n                      limits = limits,\n                      direction = 1\n                    ) +\n                    facet_wrap(\"term\") +\n                    theme_void() \n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Correlations between effects of different neighbors (MCMC predictions)\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/neighbor_type_correlations_mcmc.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/neighbor_type_correlations_mcmc.png){.column-page}\n\n\n# One at a time\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- dat |> \n  filter(is.finite(x), is.finite(y)) |> \n  select(-neighbor) |> \n  # pivot_wider(names_from = type, values_from = x) |> \n  group_by(station, model_type, type) |> \n  group_modify(\n    function(data, ...) {\n      \n      lm(y ~ x - 1, data = data) |> \n        tidy()\n    }\n  ) |> \n  ungroup()\n \nresults |> \n  write_parquet(\"Data/univariate.parquet\")\n```\n:::\n\n\n\n## Mean values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunivariate <- read_parquet(\"Data/univariate.parquet\")\n\nplot_dat <- univariate |> \n  select(station, model_type, type, estimate) |> \n  summarise(\n    mean = mean(estimate),\n    sd = sd(estimate),\n    .by = c(type, model_type)\n  ) |> \n  inner_join(\n    neighbor_types,\n    by = \"type\"\n  ) \n\nmax_est <- max(plot_dat$mean, na.rm = T)\nmin_est <- min(plot_dat$mean, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(0, 1) * scale_size\n\n\np <- plot_dat |> \n  ggplot(aes(diff_x, diff_y, fill = mean)) +\n  geom_raster() + \n  scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits, direction = 1) +\n  facet_wrap(\"model_type\")\n\nggsave(\n  plot = p,\n  filename = \"Figures/mean_neighbor_effect_univariate.png\",\n  width = 8, height = 0.621 * 8, scale = 1.2,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/mean_neighbor_effect_univariate.png){.column-page}\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- plot_dat |> \n  select(-sd) |> \n  pivot_wider(names_from = model_type, values_from = mean) |> \n  ggplot(aes(mcmc, ml)) +\n  geom_abline(intercept = 0, slope = 1, lty = 2) +\n  geom_point() +\n  labs(\n    x = \"Neighour effect from spatial model\",\n    y = \"Neighbour effect from ML model\",\n    title = \"Comparison of neighbour effects in ML and MCMC models\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/compare_mean_neighbor_effect_univariate.png\",\n  width = 8, height = 0.621 * 8, scale = 1.2,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/compare_mean_neighbor_effect_univariate.png){.column-page}\n\n\n## Spatial Distribution\n\n### Maximum Likelihood\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- univariate |> \n  filter(model_type == \"ml\") |> \n  select(station, type, estimate = statistic) |> \n  mutate(\n    estimate = case_when(\n      estimate > quantile(estimate, 0.995) ~ quantile(estimate, 0.995),\n      estimate < quantile(estimate, 0.005) ~ quantile(estimate, 0.005),\n      TRUE ~ estimate\n    ),\n    .by = type\n  ) |> \n  inner_join(\n    stations,\n    by = \"station\"\n  )\n\n\nmax_est <- max(plot_dat$estimate, na.rm = T)\nmin_est <- min(plot_dat$estimate, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(0, 1) * scale_size\n\n# plot_dat |>\n#   filter(type == \"ww\") |>\n#   ggplot(aes(proj_x, proj_y, fill = estimate)) +\n#   geom_raster(interpolate = TRUE) +\n#   scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits) +\n#   facet_wrap(\"type\")\n\nplots <- plot_dat |> \n  mutate(term = type) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(proj_x, proj_y, fill = estimate)) +\n                    geom_raster(interpolate = TRUE) +\n                    # scale_fill_distiller(\n                    #   type = \"div\",\n                    #   palette = \"RdBu\",\n                    #   limits = limits,\n                    #   direction = 1\n                    # ) +\n                    scale_fill_viridis_c(limits = limits) +\n                    facet_wrap(\"term\") +\n                    theme_void() +\n                    labs(\n                      fill = \"t-statistic\"\n                    )\n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Spatial distributions of neighbor effects in t-copula (ML Predictions)\",\n    subtitle = \"Shown as t-statistics of linear model coefficients\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_dist_by_neighbor_type_ml_univariate.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/spatial_dist_by_neighbor_type_ml_univariate.png){.column-page}\n\n### Spatial Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- univariate |> \n  filter(model_type == \"mcmc\") |> \n  select(station, type, estimate) |> \n    mutate(\n    estimate = case_when(\n      estimate > quantile(estimate, 0.995) ~ quantile(estimate, 0.995),\n      estimate < quantile(estimate, 0.005) ~ quantile(estimate, 0.005),\n      TRUE ~ estimate\n    ),\n    .by = type\n  ) |> \n  inner_join(\n    stations,\n    by = \"station\"\n  )\n\n\nmax_est <- max(plot_dat$estimate, na.rm = T)\nmin_est <- min(plot_dat$estimate, na.rm = T)\nscale_size <- max(abs(max_est), abs(min_est), na.rm = T)\nlimits <- c(0, 1) * scale_size\n\n# plot_dat |>\n#   filter(type == \"ww\") |>\n#   ggplot(aes(proj_x, proj_y, fill = estimate)) +\n#   geom_raster(interpolate = TRUE) +\n#   scale_fill_distiller(type = \"div\", palette = \"RdBu\", limits = limits) +\n#   facet_wrap(\"type\")\n\nplots <- plot_dat |> \n  mutate(term = type) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(proj_x, proj_y, fill = estimate)) +\n                    geom_raster(interpolate = TRUE) +\n                    # scale_fill_distiller(\n                    #   type = \"div\",\n                    #   palette = \"RdBu\",\n                    #   limits = limits,\n                    #   direction = 1\n                    # ) +\n                    scale_fill_viridis_c(limits = limits) +\n                    facet_wrap(\"term\") +\n                    theme_void()\n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Spatial distributions of neighbor effects in t-copula (MCMC Predictions)\",\n    subtitle = \"Shown as t-statistics of linear model coefficients\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/spatial_dist_by_neighbor_type_mcmc_univariate.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/spatial_dist_by_neighbor_type_mcmc_univariate.png){.column-page}\n\n## Parameter Correlations\n\n### Maximum Likelihood\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- univariate |> \n  filter(model_type == \"ml\") |> \n  select(station, type, estimate) |> \n  pivot_wider(names_from = type, values_from = estimate) |> \n  ungroup() |> \n  select(-station) |> \n  correlate(method = \"pearson\", use = \"pairwise.complete.obs\", quiet = T) |> \n  pivot_longer(c(-term), names_to = \"term2\", values_to = \"correlation\") |> \n  inner_join(\n    neighbor_types,\n    by = c(\"term2\" = \"type\")\n  )\n\nmax_cor <- max(plot_dat$correlation, na.rm = T)\nmin_cor <- min(plot_dat$correlation, na.rm = T)\nscale_size <- max(abs(max_cor), abs(min_cor), na.rm = T)\nlimits <- c(0, 1) * scale_size\n\n\n\n\nplots <- plot_dat |> \n  mutate(type = term) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(diff_x, diff_y, fill = correlation)) +\n                    geom_raster() +\n                    # scale_fill_viridis_c(guide = guide_colorbar(), limits = limits) +\n                    scale_fill_distiller(\n                      type = \"div\",\n                      palette = \"RdBu\",\n                      limits = limits,\n                      direction = 1\n                    ) +\n                    # scale_fill_viridis_c(limits = limits) +\n                    facet_wrap(\"term\") +\n                    theme_void() \n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Correlations between effects of different neighbors (ML predictions)\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/neighbor_type_correlations_ml_univariate.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/neighbor_type_correlations_ml_univariate.png){.column-page}\n\n### Spatial model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_dat <- univariate |> \n  filter(model_type == \"mcmc\") |> \n  select(station, type, estimate) |> \n  pivot_wider(names_from = type, values_from = estimate) |> \n  ungroup() |> \n  select(-station) |> \n  correlate(method = \"pearson\", use = \"pairwise.complete.obs\", quiet = T) |> \n  pivot_longer(c(-term), names_to = \"term2\", values_to = \"correlation\") |> \n  inner_join(\n    neighbor_types,\n    by = c(\"term2\" = \"type\")\n  )\n\nmax_cor <- max(plot_dat$correlation, na.rm = T)\nmin_cor <- min(plot_dat$correlation, na.rm = T)\nscale_size <- max(abs(max_cor), abs(min_cor), na.rm = T)\nlimits <- c(0, 1) * scale_size\n\n\n\n\nplots <- plot_dat |> \n  mutate(type = term) |> \n  group_by(type) |> \n  group_nest() |> \n  mutate(\n    plots = map(data, \n                function(data, ...) {\n                  data |> \n                    ggplot(aes(diff_x, diff_y, fill = correlation)) +\n                    geom_raster() +\n                    # scale_fill_viridis_c(guide = guide_colorbar(), limits = limits) +\n                    scale_fill_distiller(\n                      type = \"div\",\n                      palette = \"RdBu\",\n                      limits = limits,\n                      direction = 1\n                    ) +\n                    # scale_fill_viridis_c(limits = limits) +\n                    facet_wrap(\"term\") +\n                    theme_void() \n                }\n    )\n  ) |> \n  select(type, plots) |> \n  pivot_wider(names_from = type, values_from = plots)\n\n\nlayout <- \"\n##A##\n#BCD#\nEF#GH\n#IJK#\n##L##\n\"\n\n\np <- plots$nn[[1]] + \n  plots$nw[[1]] + plots$n[[1]] + plots$ne[[1]] +\n  plots$ww[[1]] + plots$w[[1]] + plots$e[[1]] + plots$ee[[1]] +\n  plots$sw[[1]] + plots$s[[1]] + plots$se[[1]] +\n  plots$ss[[1]] +\n  plot_layout(\n    design = layout, \n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Correlations between effects of different neighbors (MCMC predictions)\"\n  )\n\nggsave(\n  plot = p,\n  filename = \"Figures/neighbor_type_correlations_mcmc_univariate.png\",\n  width = 8, height = 8, scale = 1,\n  dpi = 320,\n  bg = \"white\"\n)\n```\n:::\n\n\n![](Figures/neighbor_type_correlations_mcmc_univariate.png){.column-page}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}